# Реализовать решение следующей задачи:
# «Есть два писателя, которые по очереди в течении определенного времени (у каждого разное) пишут в одну книгу.
# Данная книга очень популярна, у неё есть как минимум 3 фаната (читателя),
# которые ждут не дождутся, чтобы прочитать новые записи из неё.

# Каждый читатель и писатель – отдельный поток.
# Одновременно книгу может читать несколько читателей, но писать единовременно может только один писатель.»

import threading
import time

lock = threading.Lock()  # Мьютекс
wrote_event = threading.Event()  # Событие "написал"
strings_count = 0  # Номер строки


def writing(name, speed):
    """Функция написания. Принимает имя писателя и его скорость письма"""
    global strings_count  # Будем работать с глобальной переменной, так писателя пишут одну книгу фиксированной длины
    while strings_count < 3:  # Фиксируем длину книги количеством строк
        with lock:  # Блокируем ресурс, чтобы пока писатель пишет, второй не имел доступа к книге
            with open('book.txt', 'a') as book:
                print(f'{name} начал писать...')
                time.sleep(speed)  # Имитируем скорость письма автора соответствующей паузой
                book.write(f'Строка {strings_count + 1}\n')  # Записываем строку в файл книги
                print(f'{name} написал: Строка {strings_count + 1}')  # Вывод в интерпретатор для наглядности
                strings_count += 1  # Сообщаем глобальной переменной, что длинна книги увеличилась на одну строку
            wrote_event.set()  # Сообщаем читателю, что ещё одна запись сделана - можно читать
            time.sleep(1)  # Ждём, чтобы дать возможность второму потоку писателя захватить управление (для очерёдности)


def reading(reader_num):
    """Функция чтения. Принимает в качестве агрумента номер читателя."""
    while True:  # Читатель постоянно ждёт...
        wrote_event.wait()  # ...сигнала от писателя, что появилась новая запись и можно читать
        with open('book.txt', 'r') as book:
            for line in book:  # Перебирает все строки книги
                last_line = line  # И находит последнюю
            print(f'Читатель {reader_num} прочитал: {last_line[:-1]}')  # "Читает" последнюю строку
            wrote_event.clear()  # Переходит в режим ожидания следующего сигнала от писателя


# Объявление потоков, старт и присоединение к основному потоку интерпретатора
writer1 = threading.Thread(target=writing, args=('Гоголь', 4))
writer2 = threading.Thread(target=writing, args=('Пушкин', 2))

# Читатели - демоны, так как всегда находятся в режиме ожидания. Их нужно убить, когда писатели закончат писать.
reader1 = threading.Thread(target=reading, daemon=True, args=('1',))
reader2 = threading.Thread(target=reading, daemon=True, args=('2',))
reader3 = threading.Thread(target=reading, daemon=True, args=('3',))

writer1.start()
writer2.start()

reader1.start()
reader2.start()
reader3.start()

writer1.join()
writer2.join()
